// =============================================
// SPI Slave Core - Auto-generated by SPI Customizer
// =============================================

module spi_slave #(
    parameter MODE = {{MODE}},                    // SPI mode (0, 1, 2, 3)
    parameter DATA_WIDTH = {{DATA_WIDTH}},        // Data width in bits
    parameter SLAVE_ACTIVE_LOW = {{SLAVE_ACTIVE_LOW|int}},  // Slave select polarity
    parameter MSB_FIRST = {{MSB_FIRST|int}},  // Data order
    parameter FIFO_DEPTH = {{FIFO_DEPTH}},        // FIFO buffer depth
    parameter MAX_SLAVES = {{MAX_SLAVES}},        // Maximum slaves supported
    parameter DEFAULT_DATA_ENABLED = {{DEFAULT_DATA_ENABLED|int}},
    parameter DEFAULT_DATA_PATTERN = "{{DEFAULT_DATA_PATTERN}}",
    parameter DEFAULT_DATA_VALUE = 16'h{{DEFAULT_DATA_VALUE}}
)(
    // System signals
    input  wire clk,                    // System clock
    input  wire rst_n,                  // Active-low reset

    // SPI Slave Interface
    input  wire sclk,                   // SPI clock from master
    input  wire mosi,                   // Master Out Slave In
    output wire miso,                   // Master In Slave Out
    input  wire ss_n,                   // Slave Select (active low)

    // Data interface
    output wire [DATA_WIDTH-1:0] rx_data,  // Received data
    input  wire [DATA_WIDTH-1:0] tx_data,  // Data to transmit
    output wire rx_valid,               // Receive data valid
    output wire tx_ready,               // Ready to accept new transmit data
    input  wire tx_valid,               // Transmit data valid

    // Control and status
    output wire busy,                   // SPI transaction in progress
    output wire irq,                    // Interrupt request
    input  wire irq_clear               // Clear interrupt
);

// =============================================
// Local Parameters
// =============================================
localparam FIFO_WIDTH = $clog2(FIFO_DEPTH);
localparam SLAVE_ID = 0;  // Default slave ID

// Mode parameters
localparam CPOL = (MODE >> 1);  // Clock polarity
localparam CPHA = (MODE & 1);   // Clock phase

// =============================================
// Internal Signals
// =============================================

// Clock domain signals
reg [2:0] bit_counter;
reg [2:0] state, next_state;
reg [DATA_WIDTH-1:0] shift_reg_rx;
reg [DATA_WIDTH-1:0] shift_reg_tx;
reg [DATA_WIDTH-1:0] rx_data_reg;
reg miso_reg;

// Control signals
reg ss_n_sync, ss_n_prev;
reg sclk_sync, sclk_prev;
reg sample_edge, shift_edge;

// FIFO signals
reg fifo_wr_en;
reg [DATA_WIDTH-1:0] fifo_wr_data;
wire fifo_full, fifo_empty;
wire [DATA_WIDTH-1:0] fifo_rd_data;

// Interrupt and status
reg irq_reg;
reg busy_reg;

// Default data generation
reg [DATA_WIDTH-1:0] default_data;

// =============================================
// State Machine Definition
// =============================================
localparam IDLE    = 3'b000;
localparam RECEIVE = 3'b001;
localparam TRANSMIT = 3'b010;
localparam COMPLETE = 3'b011;
localparam ERROR   = 3'b100;

// =============================================
// Default Data Pattern Generator
// =============================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        default_data <= DEFAULT_DATA_VALUE;
    end else if (DEFAULT_DATA_ENABLED) begin
        case (DEFAULT_DATA_PATTERN)
            "a5a5": default_data <= 16'hA5A5;
            "ffff": default_data <= 16'hFFFF;
            "0000": default_data <= 16'h0000;
            "5555": default_data <= 16'h5555;
            default: default_data <= DEFAULT_DATA_VALUE;
        endcase
    end
end

// =============================================
// Synchronization Registers
// =============================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        ss_n_sync <= 1'b1;
        ss_n_prev <= 1'b1;
        sclk_sync <= 1'b0;
        sclk_prev <= 1'b0;
    end else begin
        ss_n_sync <= ss_n;
        ss_n_prev <= ss_n_sync;
        sclk_sync <= sclk;
        sclk_prev <= sclk_sync;
    end
end

// =============================================
// Edge Detection
// =============================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        sample_edge <= 1'b0;
        shift_edge <= 1'b0;
    end else begin
        // Sample edge: CPHA=0 uses rising, CPHA=1 uses falling
        sample_edge <= (CPHA == 0) ? (~sclk_prev & sclk_sync) : (sclk_prev & ~sclk_sync);

        // Shift edge: opposite of sample edge
        shift_edge <= (CPHA == 0) ? (sclk_prev & ~sclk_sync) : (~sclk_prev & sclk_sync);
    end
end

// =============================================
// Main State Machine
// =============================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= IDLE;
        bit_counter <= 3'b000;
        shift_reg_rx <= {DATA_WIDTH{1'b0}};
        shift_reg_tx <= {DATA_WIDTH{1'b0}};
        rx_data_reg <= {DATA_WIDTH{1'b0}};
        miso_reg <= 1'b0;
        busy_reg <= 1'b0;
        irq_reg <= 1'b0;
    end else begin
        state <= next_state;

        case (state)
            IDLE: begin
                bit_counter <= 3'b000;
                busy_reg <= 1'b0;
                if (!ss_n_sync) begin  // Slave selected
                    busy_reg <= 1'b1;
                    shift_reg_tx <= tx_valid ? tx_data : default_data;
                end
            end

            RECEIVE: begin
                if (sample_edge) begin
                    if (MSB_FIRST) begin
                        shift_reg_rx <= {shift_reg_rx[DATA_WIDTH-2:0], mosi};
                    end else begin
                        shift_reg_rx <= {mosi, shift_reg_rx[DATA_WIDTH-1:1]};
                    end
                    bit_counter <= bit_counter + 1'b1;
                end
            end

            TRANSMIT: begin
                if (shift_edge) begin
                    if (MSB_FIRST) begin
                        miso_reg <= shift_reg_tx[DATA_WIDTH-1];
                        shift_reg_tx <= {shift_reg_tx[DATA_WIDTH-2:0], 1'b0};
                    end else begin
                        miso_reg <= shift_reg_tx[0];
                        shift_reg_tx <= {1'b0, shift_reg_tx[DATA_WIDTH-1:1]};
                    end
                    bit_counter <= bit_counter + 1'b1;
                end
            end

            COMPLETE: begin
                rx_data_reg <= shift_reg_rx;
                irq_reg <= 1'b1;
            end

            ERROR: begin
                // Handle error condition
                bit_counter <= 3'b000;
            end
        endcase
    end
end

// =============================================
// Next State Logic
// =============================================
always @(*) begin
    next_state = state;

    case (state)
        IDLE: begin
            if (!ss_n_sync) begin  // Slave selected
                next_state = RECEIVE;
            end
        end

        RECEIVE: begin
            if (bit_counter >= DATA_WIDTH) begin
                next_state = COMPLETE;
            end
        end

        COMPLETE: begin
            if (ss_n_sync) begin  // Slave deselected
                next_state = IDLE;
            end
        end

        default: next_state = IDLE;
    endcase
end

// =============================================
// Output Assignments
// =============================================
assign rx_data = rx_data_reg;
assign rx_valid = (state == COMPLETE);
assign tx_ready = (state == IDLE);
assign miso = miso_reg;
assign busy = busy_reg;
assign irq = irq_reg & ~irq_clear;

// =============================================
// FIFO Implementation (if enabled)
// =============================================
{% if FIFO_BUFFERS %}
// Simple FIFO for data buffering
reg [DATA_WIDTH-1:0] fifo_mem [0:FIFO_DEPTH-1];
reg [FIFO_WIDTH:0] fifo_wr_ptr, fifo_rd_ptr;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        fifo_wr_ptr <= 0;
        fifo_rd_ptr <= 0;
        fifo_wr_en <= 1'b0;
    end else begin
        if (fifo_wr_en && !fifo_full) begin
            fifo_mem[fifo_wr_ptr[FIFO_WIDTH-1:0]] <= fifo_wr_data;
            fifo_wr_ptr <= fifo_wr_ptr + 1;
        end
    end
end

assign fifo_full = (fifo_wr_ptr[FIFO_WIDTH-1:0] == fifo_rd_ptr[FIFO_WIDTH-1:0]) &&
                   (fifo_wr_ptr[FIFO_WIDTH] != fifo_rd_ptr[FIFO_WIDTH]);
assign fifo_empty = (fifo_wr_ptr == fifo_rd_ptr);
assign fifo_rd_data = fifo_mem[fifo_rd_ptr[FIFO_WIDTH-1:0]];

{% endif %}

// =============================================
// Debug Signals (for testing)
// =============================================
wire [2:0] debug_state = state;
wire [2:0] debug_bit_count = bit_counter;

endmodule

// =============================================
// SPI Slave Core - Auto-generated by SPI Customizer
// =============================================

module spi_slave #(
    parameter MODE = 0,                    // SPI mode (0, 1, 2, 3)
    parameter DATA_WIDTH = 8,        // Data width in bits
    parameter SLAVE_ACTIVE_LOW = 1,  // Slave select polarity
    parameter MSB_FIRST = 1,  // Data order
    parameter FIFO_DEPTH = 16,        // FIFO buffer depth
    parameter MAX_SLAVES = 8,        // Maximum slaves supported
    parameter DEFAULT_DATA_ENABLED = 0,
    parameter DEFAULT_DATA_PATTERN = "a5a5",
    parameter DEFAULT_DATA_VALUE = 16'hA5A5
)(
    // System signals
    input  wire clk,                    // System clock
    input  wire rst_n,                  // Active-low reset

    // SPI Slave Interface
    input  wire sclk,                   // SPI clock from master
    input  wire mosi,                   // Master Out Slave In
    output wire miso,                   // Master In Slave Out
    input  wire ss_n,                   // Slave Select (active low)

    // Data interface
    output wire [DATA_WIDTH-1:0] rx_data,  // Received data
    input  wire [DATA_WIDTH-1:0] tx_data,  // Data to transmit
    output wire rx_valid,               // Receive data valid
    output wire tx_ready,               // Ready to accept new transmit data
    input  wire tx_valid,               // Transmit data valid

    // Control and status
    output wire busy,                   // SPI transaction in progress
    output wire irq,                    // Interrupt request
    input  wire irq_clear               // Clear interrupt
);

// =============================================
// Local Parameters
// =============================================
localparam FIFO_WIDTH = $clog2(FIFO_DEPTH);
localparam SLAVE_ID = 0;  // Default slave ID

// Mode parameters
localparam CPOL = (MODE >> 1);  // Clock polarity
localparam CPHA = (MODE & 1);   // Clock phase

// =============================================
// Internal Signals
// =============================================

// Clock domain signals
reg [2:0] bit_counter;
reg [2:0] state, next_state;
reg [DATA_WIDTH-1:0] shift_reg_rx;
reg [DATA_WIDTH-1:0] shift_reg_tx;
reg [DATA_WIDTH-1:0] rx_data_reg;
reg miso_reg;

// Control signals
reg ss_n_sync, ss_n_prev;
reg sclk_sync, sclk_prev;
reg sample_edge, shift_edge;

// FIFO signals
reg fifo_wr_en;
reg [DATA_WIDTH-1:0] fifo_wr_data;
wire fifo_full, fifo_empty;
wire [DATA_WIDTH-1:0] fifo_rd_data;

// Interrupt and status
reg irq_reg;
reg busy_reg;

// Default data generation
reg [DATA_WIDTH-1:0] default_data;

// =============================================
// State Machine Definition
// =============================================
localparam IDLE    = 3'b000;
localparam RECEIVE = 3'b001;
localparam TRANSMIT = 3'b010;
localparam COMPLETE = 3'b011;
localparam ERROR   = 3'b100;

// =============================================
// Default Data Pattern Generator
// =============================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        default_data <= DEFAULT_DATA_VALUE;
    end else if (DEFAULT_DATA_ENABLED) begin
        case (DEFAULT_DATA_PATTERN)
            "a5a5": default_data <= 16'hA5A5;
            "ffff": default_data <= 16'hFFFF;
            "0000": default_data <= 16'h0000;
            "5555": default_data <= 16'h5555;
            default: default_data <= DEFAULT_DATA_VALUE;
        endcase
    end
end

// =============================================
// Synchronization Registers
// =============================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        ss_n_sync <= 1'b1;
        ss_n_prev <= 1'b1;
        sclk_sync <= 1'b0;
        sclk_prev <= 1'b0;
    end else begin
        ss_n_sync <= ss_n;
        ss_n_prev <= ss_n_sync;
        sclk_sync <= sclk;
        sclk_prev <= sclk_sync;
    end
end

// =============================================
// Edge Detection
// =============================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        sample_edge <= 1'b0;
        shift_edge <= 1'b0;
    end else begin
        // Sample edge: CPHA=0 uses rising, CPHA=1 uses falling
        sample_edge <= (CPHA == 0) ? (~sclk_prev & sclk_sync) : (sclk_prev & ~sclk_sync);

        // Shift edge: opposite of sample edge
        shift_edge <= (CPHA == 0) ? (sclk_prev & ~sclk_sync) : (~sclk_prev & sclk_sync);
    end
end

// =============================================
// Main State Machine
// =============================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= IDLE;
        bit_counter <= 3'b000;
        shift_reg_rx <= {DATA_WIDTH{1'b0}};
        shift_reg_tx <= {DATA_WIDTH{1'b0}};
        rx_data_reg <= {DATA_WIDTH{1'b0}};
        miso_reg <= 1'b0;
        busy_reg <= 1'b0;
        irq_reg <= 1'b0;
    end else begin
        state <= next_state;

        case (state)
            IDLE: begin
                bit_counter <= 3'b000;
                busy_reg <= 1'b0;
                if (!ss_n_sync) begin  // Slave selected
                    busy_reg <= 1'b1;
                    shift_reg_tx <= tx_valid ? tx_data : default_data;
                end
            end

            RECEIVE: begin
                if (sample_edge) begin
                    if (MSB_FIRST) begin
                        shift_reg_rx <= {shift_reg_rx[DATA_WIDTH-2:0], mosi};
                    end else begin
                        shift_reg_rx <= {mosi, shift_reg_rx[DATA_WIDTH-1:1]};
                    end
                    bit_counter <= bit_counter + 1'b1;
                end
            end

            TRANSMIT: begin
                if (shift_edge) begin
                    if (MSB_FIRST) begin
                        miso_reg <= shift_reg_tx[DATA_WIDTH-1];
                        shift_reg_tx <= {shift_reg_tx[DATA_WIDTH-2:0], 1'b0};
                    end else begin
                        miso_reg <= shift_reg_tx[0];
                        shift_reg_tx <= {1'b0, shift_reg_tx[DATA_WIDTH-1:1]};
                    end
                    bit_counter <= bit_counter + 1'b1;
                end
            end

            COMPLETE: begin
                rx_data_reg <= shift_reg_rx;
                irq_reg <= 1'b1;
            end

            ERROR: begin
                // Handle error condition
                bit_counter <= 3'b000;
            end
        endcase
    end
end

// =============================================
// Next State Logic
// =============================================
always @(*) begin
    next_state = state;

    case (state)
        IDLE: begin
            if (!ss_n_sync) begin  // Slave selected
                next_state = RECEIVE;
            end
        end

        RECEIVE: begin
            if (bit_counter >= DATA_WIDTH) begin
                next_state = COMPLETE;
            end
        end

        COMPLETE: begin
            if (ss_n_sync) begin  // Slave deselected
                next_state = IDLE;
            end
        end

        default: next_state = IDLE;
    endcase
end

// =============================================
// Output Assignments
// =============================================
assign rx_data = rx_data_reg;
assign rx_valid = (state == COMPLETE);
assign tx_ready = (state == IDLE);
assign miso = miso_reg;
assign busy = busy_reg;
assign irq = irq_reg & ~irq_clear;

// =============================================
// FIFO Implementation (if enabled)
// =============================================


// =============================================
// Debug Signals (for testing)
// =============================================
wire [2:0] debug_state = state;
wire [2:0] debug_bit_count = bit_counter;

endmodule
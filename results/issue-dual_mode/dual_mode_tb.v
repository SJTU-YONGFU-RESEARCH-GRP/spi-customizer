// =============================================
// SPI Dual Mode Testbench - Auto-generated by SPI Customizer
// =============================================

`timescale 1ns / 1ps

module spi_dual_tb;

    // Parameters
    parameter MODE = 1;
    parameter DATA_WIDTH = 16;
    parameter NUM_SLAVES = 2;
    parameter SLAVE_ACTIVE_LOW = 1;
    parameter MSB_FIRST = 1;
    parameter FIFO_DEPTH = 32;
    parameter MAX_SLAVES = 8;
    parameter CLOCK_DIVIDER = 4;
    parameter DEFAULT_DATA_ENABLED = 0;
    parameter DEFAULT_DATA_PATTERN = "FFFF";
    parameter DEFAULT_DATA_VALUE = 16'hA5A5;

    // Signals
    reg clk;
    reg rst_n;
    reg master_mode;
    wire sclk;
    wire mosi;
    reg miso;
    wire [NUM_SLAVES-1:0] ss_n;
    reg sclk_in;
    reg mosi_in;
    wire miso_out;
    reg ss_in;
    reg [DATA_WIDTH-1:0] tx_data;
    wire [DATA_WIDTH-1:0] rx_data;
    wire rx_valid;
    wire tx_ready;
    wire busy;
    wire irq;

    // DUT instantiation
    spi_dual #(
        .MODE(MODE),
        .DATA_WIDTH(DATA_WIDTH),
        .NUM_SLAVES(NUM_SLAVES),
        .SLAVE_ACTIVE_LOW(SLAVE_ACTIVE_LOW),
        .MSB_FIRST(MSB_FIRST),
        .FIFO_DEPTH(FIFO_DEPTH),
        .MAX_SLAVES(MAX_SLAVES),
        .CLOCK_DIVIDER(CLOCK_DIVIDER),
        .DEFAULT_DATA_ENABLED(DEFAULT_DATA_ENABLED),
        .DEFAULT_DATA_PATTERN(DEFAULT_DATA_PATTERN),
        .DEFAULT_DATA_VALUE(DEFAULT_DATA_VALUE)
    ) dut (
        .clk(clk),
        .rst_n(rst_n),
        .master_mode(master_mode),
        .sclk(sclk),
        .mosi(mosi),
        .miso(miso),
        .ss_n(ss_n),
        .sclk_in(sclk_in),
        .mosi_in(mosi_in),
        .miso_out(miso_out),
        .ss_in(ss_in),
        .rx_data(rx_data),
        .tx_data(tx_data),
        .rx_valid(rx_valid),
        .tx_ready(tx_ready),
        .tx_valid(tx_ready),  // Use tx_ready as tx_valid input
        .busy(busy),
        .irq(irq),
        .irq_clear(1'b0)
    );

    // Clock generation
    initial begin
        clk = 0;
        forever #10 clk = ~clk;  // 50MHz clock
    end

    // Test sequence for dual mode
    initial begin
        // Initialize
        rst_n = 0;
        master_mode = 1;  // Start in master mode
        tx_data = 0;
        miso = 0;
        sclk_in = 0;
        mosi_in = 0;
        ss_in = 1;

        #100;
        rst_n = 1;
        #200;  // Allow system to stabilize

        $display("=== SPI Dual Mode RTL Testbench Starting ===");
        $display("Configuration: Mode %d, %d-bit data, Dual mode", MODE, DATA_WIDTH);

        // Test master mode first
        $display("--- Testing Master Mode ---");

        // Test basic transmission in master mode
        tx_data = 16'hAA55;
        $display("TX Data: 0x%h", tx_data);
        #100;

        // Switch to slave mode after master test
        #500;
        master_mode = 0;
        $display("--- Switched to Slave Mode ---");

        // Test slave mode with simulated master transactions
        #100;
        ss_in = 0;  // Select slave
        $display("Slave selected - testing slave mode");

        // Generate SPI clock cycles to test slave
        repeat (16) begin  // 16 bits
            #25;
            sclk_in = ~sclk_in;
            if (sclk_in) begin
                mosi_in = $random % 2;  // Random data from simulated master
            end
        end

        #100;
        ss_in = 1;  // Deselect slave
        $display("âœ“ Slave mode test complete");

        $display("=== All Dual Mode Tests Completed Successfully ===");
        $finish;
    end

    // VCD dumping
    initial begin
        $dumpfile("spi_waveform.vcd");
        $dumpvars(0, spi_dual_tb);
    end

endmodule
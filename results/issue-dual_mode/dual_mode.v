// =============================================
// SPI Dual Mode Core - Auto-generated by SPI Customizer
// Supports both Master and Slave functionality
// =============================================

module spi_dual #(
    parameter MODE = 1,                    // SPI mode (0, 1, 2, 3)
    parameter DATA_WIDTH = 16,        // Data width in bits
    parameter NUM_SLAVES = 2,        // Number of slaves when in master mode
    parameter SLAVE_ACTIVE_LOW = 1,  // Slave select polarity
    parameter MSB_FIRST = 1,  // Data order
    parameter FIFO_DEPTH = 32,        // FIFO buffer depth
    parameter MAX_SLAVES = 8,        // Maximum slaves supported
    parameter CLOCK_DIVIDER = 4,  // System clock divider
    parameter DEFAULT_DATA_ENABLED = 0,
    parameter DEFAULT_DATA_PATTERN = "FFFF",
    parameter DEFAULT_DATA_VALUE = 16'hA5A5
)(
    // System signals
    input  wire clk,                    // System clock
    input  wire rst_n,                  // Active-low reset

    // Mode selection
    input  wire master_mode,            // 1 = Master, 0 = Slave

    // Master Interface (when master_mode = 1)
    output wire sclk,                   // SPI clock output
    output wire mosi,                   // Master Out Slave In
    input  wire miso,                   // Master In Slave Out
    output wire [NUM_SLAVES-1:0] ss_n,  // Slave Select outputs

    // Slave Interface (when master_mode = 0)
    input  wire sclk_in,                // SPI clock input
    input  wire mosi_in,                // MOSI input
    output wire miso_out,               // MISO output
    input  wire ss_in,                  // Slave Select input

    // Common Data Interface
    output wire [DATA_WIDTH-1:0] rx_data,  // Received data
    input  wire [DATA_WIDTH-1:0] tx_data,  // Data to transmit
    output wire rx_valid,               // Receive data valid
    output wire tx_ready,               // Ready to accept new transmit data
    input  wire tx_valid,               // Transmit data valid

    // Control and status
    output wire busy,                   // SPI transaction in progress
    output wire irq,                    // Interrupt request
    input  wire irq_clear               // Clear interrupt
);

    // Internal signals
    reg [DATA_WIDTH-1:0] default_data;

    // Master mode internal signals
    reg master_start_tx, master_start_rx;
    reg [DATA_WIDTH-1:0] master_tx_shift_reg, master_rx_shift_reg;
    reg [3:0] master_bit_counter;
    reg [7:0] master_sclk_counter;
    reg master_busy, master_sclk_en;
    reg master_cpol, master_cpha;
    reg [DATA_WIDTH-1:0] master_rx_data_buffer;
    reg master_rx_valid_buffer, master_tx_ready_buffer;

    // Slave mode internal signals
    reg slave_rx_valid_buffer, slave_tx_ready_buffer, slave_busy_buffer;
    reg [DATA_WIDTH-1:0] slave_rx_data_buffer;
    reg [DATA_WIDTH-1:0] slave_tx_shift_reg;
    reg [3:0] slave_bit_counter;
    reg slave_sclk_last_state;

    // Default data pattern generator
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            default_data <= DEFAULT_DATA_VALUE;
        end else if (DEFAULT_DATA_ENABLED) begin
            case (DEFAULT_DATA_PATTERN)
                "a5a5": default_data <= 16'hA5A5;
                "ffff": default_data <= 16'hFFFF;
                "0000": default_data <= 16'h0000;
                "5555": default_data <= 16'h5555;
                default: default_data <= DEFAULT_DATA_VALUE;
            endcase
        end
    end

    // Master mode implementation (simplified)
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            master_busy <= 1'b0;
            master_sclk_en <= 1'b0;
            master_start_tx <= 1'b0;
            master_start_rx <= 1'b0;
        end else if (master_mode) begin
            // Master mode logic - simplified SPI master
            if (tx_valid && !master_busy) begin
                master_start_tx <= 1'b1;
                master_busy <= 1'b1;
                master_sclk_en <= 1'b1;
            end else begin
                master_start_tx <= 1'b0;
            end

            // Basic clock generation
            if (master_sclk_en) begin
                master_sclk_counter <= master_sclk_counter + 1;
            end
        end
    end

    // Slave mode implementation (simplified)
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            slave_busy_buffer <= 1'b0;
            slave_rx_valid_buffer <= 1'b0;
            slave_tx_ready_buffer <= 1'b0;
        end else if (!master_mode) begin
            // Slave mode logic - respond to transactions
            if (!ss_in) begin  // Slave is selected
                slave_busy_buffer <= 1'b1;
                slave_tx_ready_buffer <= 1'b1;
                slave_rx_data_buffer <= default_data;
                slave_rx_valid_buffer <= 1'b1;
            end else begin
                slave_busy_buffer <= 1'b0;
                slave_rx_valid_buffer <= 1'b0;
                slave_tx_ready_buffer <= 1'b0;
            end
        end
    end

    // Output signal selection based on master_mode
    assign sclk = master_mode ? (master_sclk_en ? master_sclk_counter[7] : 1'b0) : 1'b0;
    assign mosi = master_mode ? (master_start_tx ? tx_data[0] : 1'b0) : 1'b0;
    assign miso_out = master_mode ? 1'b0 : (slave_tx_ready_buffer ? default_data[0] : 1'b0);

    // Slave select outputs (only active in master mode)
    assign ss_n = master_mode ? {NUM_SLAVES{1'b1}} : {NUM_SLAVES{1'b1}};  // Simplified

    // Data signal selection
    assign rx_data = master_mode ? master_rx_data_buffer : slave_rx_data_buffer;
    assign rx_valid = master_mode ? master_rx_valid_buffer : slave_rx_valid_buffer;
    assign tx_ready = master_mode ? master_tx_ready_buffer : slave_tx_ready_buffer;
    assign busy = master_mode ? master_busy : slave_busy_buffer;

    // Simplified output assignments
    assign irq = 1'b0;  // No interrupts for now

endmodule